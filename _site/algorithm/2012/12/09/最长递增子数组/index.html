
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>求数组的最长递增子数组</title>
    
    <meta name="author" content="Jay shaolianbo">

    <!-- Enable responsive viewport -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le styles -->
    <link href="/assets/themes/twitter/bootstrap/css/bootstrap.2.2.2.min.css" rel="stylesheet">
    <link href="/assets/themes/twitter/css/style.css?body=1" rel="stylesheet" type="text/css" media="all">

    <!-- Le fav and touch icons -->
  <!-- Update these with your own images
    <link rel="shortcut icon" href="images/favicon.ico">
    <link rel="apple-touch-icon" href="images/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="72x72" href="images/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="114x114" href="images/apple-touch-icon-114x114.png">
  -->

    <!-- atom & rss feed -->
    <link href="/atom.xml" type="application/atom+xml" rel="alternate" title="Sitewide ATOM Feed">
    <link href="/rss.xml" type="application/rss+xml" rel="alternate" title="Sitewide RSS Feed">

  </head>

  <body>
    <div class="navbar">
      <div class="navbar-inner">
        <div class="container-narrow">
          <a class="brand" href="/">Seven</a>
          <ul class="nav">
            
            
            


  
    
      
    
  
    
      
      	
      	<li><a href="/tags.html">Tags</a></li>
      	
      
    
  
    
      
      	
      	<li><a href="/categories.html">Categories</a></li>
      	
      
    
  
    
      
    
  
    
      
      	
      	<li><a href="/archive.html">Archive</a></li>
      	
      
    
  
    
      
    
  
    
      
      	
      	<li><a href="/pages.html">Pages</a></li>
      	
      
    
  
    
      
    
  



          </ul>
        </div>
      </div>
    </div>

    <div class="container-narrow">

      <div class="content">
        
<div class="page-header">
  <h1>求数组的最长递增子数组 </h1>
</div>

<div class="row-fluid post-full">
  <div class="span12">
    <div class="date">
      <span>09 December 2012</span>
    </div>
    <div class="content">
      <h3 id="">问题：求数组的最长递增子数组的长度。</h3>

<p>eg: 输入数组{1,-1,2,-3,4,-5,6,-7},因为最长递增子数组为 1 2 4 6 ,所以返回4.</p>

<h3 id="_2">方法一：</h3>

<p>显然如果能穷举所有的递增子数组（不相包含），就可以得到最长的是什么。 假设有一个递增子串的集合，遍历数组的过程中维护这个集合：</p>

<pre><code>索引   元素       子串集合
0      1           1

1      -1          1；-1

2      2           1，2；-1，2

3      -3          1，2；-1，2；-3

4      4           1，2，4；-1，2，4；-3，4

5      -5          1，2，4；-1，2，4；-3，4；-5

6      6           1，2，4，6；-1，2，4，6；-3，4，6；-5，6

7      -7          1，2，4，6；-1，2，4，6；-3，4，6；-5，6;-7</code></pre>

<p>输出4</p>

<p>但问题只要求最长递增子串的长度，不必求字串的内容，可以简化： 我们是这样构造子串的： 当我们读到第三个数2时，只要求出以2结尾的串的最大长度就可以了。这样其后如果是比2大的数字，可在他的长度上递 增，其后是比2小的数与这里的计算结果就不搭了。最后我们求出的是以各个位置的数字结尾的递增字串的对大长度。 其中最大值即为输出。</p>

<p>故得到解结构： 输入pin,第i个数子结尾时，字串的最大长度 <code>longest[i]=max{1,longest[k]} 1&lt;=k&lt;i &amp;&amp; pin[k]&lt;pin[i]</code></p>

<p>故有时间复杂度为O(n^2)的算法1：</p>

<pre><code>int longestA(int* pin,int length)  
{  
	int longest[length];  
	longest[0]=1;  
	int max=1;  
	for(int i=1;i&lt;length;i++)  
	{  
		longest[i]=1;  
		for(int j=0;j&lt;i;j++)  
		{  
			if(pin[j]&lt;pin[i] &amp;&amp; longest[j]+1&gt;longest[i])  
				longest[i]=longest[j]+1;  
		}  
		if(longest[i]&gt;max)  
			max=longest[i];  
	}  
	return max;  

}  </code></pre>

<h3 id="_3">方法二：</h3>

<p>考虑对其方法一优化，求longset[i]时，遍历了之前所有的longsest结果。我门需要找到的是以小于pin[i]结尾的，长度最大 长的字串。故可以记录这两个量的组合：子串长度—结尾数字，而相同的长度会有不同的尾数字，我门只在意最小的 那个是否<code>&lt;pin[i]</code>,小则可以得到更长的子串。故该组合应为：子串长度—-结尾数字的最小值。我们将所有组合按 长度从小到大排列，长度最大且结尾数字<code>&lt;pin[i]</code> 的。</p>

<p>算法2时间复杂度仍O(n^2)</p>

<pre><code>int longestB(int* pin,int length)  
{  
	int minTail[length+1];  
	minTail[1]=pin[0];  
	int maxlengh=1;  
	  
	for(int i=1;i&lt;length;i++)  
	{  
		int mylength=1;  
		for(int j=maxlengh;j&gt;=1;j--)  
			 {  
				 if(pin[i]&gt;minTail[j])  
					 {  
						 mylength=j+1;  
						 break;  
					 }  
			 }  
		if(mylength&gt;maxlengh)  
		{  
		   minTail[mylength]=pin[i];  
		   maxlengh=mylength;  
		}  
		else  
		{  
			if(pin[i]&lt;minTail[mylength])  
				minTail[mylength]=pin[i];  
		}  
	}  
	return maxlengh;  
}  </code></pre>

<h3 id="_4">方法三：</h3>

<p>数组minTail[i] ,表示长度为i的递增子串的最小尾数. 实际上存在如下关系： 如果<code>i&lt;j</code> 那么<code>minTail[i]&lt;minTail[j]</code> 证明： 假设<code>minTail[j]&lt;=minTail[i]</code>,则长度j的串中长度为i的子串其尾数必然<code>&lt;minTail[i]</code>.这和数组minTail的定义矛盾。</p>

<p>所以可以用二分查找实现在minTail中的查找： 算法复杂读为O(nlongn)</p>

<pre><code>//二分查找，找第一个比n小的。  
int halfSearch(int* pin,int nstart,int nend,int n)  
{  
	int mid;  
	int nlow=nstart;  
	int nhigh=nend;  
	while(nhigh&gt;=nlow)                //只有当所有数都大于n时，条件不成立，返回1  
	{  
		mid=(nhigh+nlow)/2;  
		if(pin[mid]&lt;n &amp;&amp; ( mid+1&gt;nend||pin[mid+1]&gt;=n))  
			return mid;                    //只要有小于n的元素就从这里返回  
		else  
			if( pin[mid]&gt;=n)  
				  nhigh=mid-1;  
			else  
				nlow=mid+1;  
	}  
	return 0;  
}  
  
  
int longestC(int* pin,int length)  
{  
	int minTail[length+1];  
	minTail[1]=pin[0];  
	int maxlengh=1;  
	  
	for(int i=1;i&lt;length;i++)  
	{  
		int mylength=halfSearch(minTail,1,maxlengh,pin[i])+1;  
		if(mylength&gt;maxlengh)  
		{  
		   minTail[mylength]=pin[i];  
		   maxlengh=mylength;  
		}  
		else  
		{  
			if(pin[i]&lt;minTail[mylength])  
				minTail[mylength]=pin[i];  
		}  
	}  
	return maxlengh;  
}  </code></pre>
    </div>

  
    <ul class="tag_box inline">
      <li><i class="icon-folder-open"></i></li>
      
      


  
     
    	<li><a href="/categories.html#algorithm-ref">
    		algorithm <span>9</span>
    	</a></li>
    
  


    </ul>
    

  
    <ul class="tag_box inline">
      <li><i class="icon-tags"></i></li>
      
      


  
     
    	<li><a href="/tags.html#algorithm-ref">algorithm <span>8</span></a></li>
    
  



    </ul>
    

    <hr>
    <div class="pagination">
      <ul>
      
        <li class="prev"><a href="/algorithm/2012/12/09/cpp%E5%8D%95%E6%80%81%E6%A8%A1%E5%BC%8F" title="cpp单态模式">&larr; Previous</a></li>
      
        <li><a href="/archive.html">Archive</a></li>
      
        <li class="next"><a href="/algorithm/2012/12/10/%E6%B1%82%E6%95%B0%E7%BB%84%E5%89%8Dk%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8" title="求数组的前k小的元素，及其应用">Next &rarr;</a></li>
      
      </ul>
    </div>
    <hr>
    <!-- Duoshuo Comment BEGIN -->
<div class="ds-thread"></div>
<script type="text/javascript">
var duoshuoQuery = {short_name:"shaolianbo"};
(function() {
 var ds = document.createElement('script');
 ds.type = 'text/javascript';ds.async = true;
 ds.src = 'http://static.duoshuo.com/embed.js';
 ds.charset = 'UTF-8';
 (document.getElementsByTagName('head')[0] 
  || document.getElementsByTagName('body')[0]).appendChild(ds);
 })();
</script>
<!-- Duoshuo Comment END -->

  </div>
</div>


      </div>
      <hr>
      <footer>
        <p>&copy; 2014 Jay shaolianbo
          with help from <a href="http://jekyllbootstrap.com" target="_blank" title="The Definitive Jekyll Blogging Framework">Jekyll Bootstrap</a>
          and <a href="http://twitter.github.com/bootstrap/" target="_blank">Twitter Bootstrap</a>
        </p>
      </footer>

    </div>

    
  </body>
</html>

